## 1. 운영체제
### 1. 운영체제 
 - 운영체제는 하드웨어와 사용자(또는 응용 프로그램) 사이의 중개자 역할을 하면서, 자원을 효율적으로 관리하고 프로그램 실행을 가능하게 만들어주는 시스템 소프트웨어
 
### 2. 운영체제의 역할
| 역할                | 설명                                              |
| ----------------- | ----------------------------------------------- |
| **프로세스 관리**     | 실행 중인 프로그램(프로세스)의 생성, 종료, 스케줄링, 동기화, 통신 등을 관리함  |
| **메모리 관리**     | RAM 공간을 적절히 나누고, 프로세스에 메모리를 할당/회수하며 가상 메모리를 관리함 |
| **파일 시스템 관리**  | 파일의 생성, 삭제, 읽기/쓰기, 접근 권한 등을 관리하고 디스크 자원을 조직화함   |
| **입출력(I/O) 관리** | 키보드, 마우스, 디스크, 네트워크 등 주변 장치와의 데이터 입출력을 관리함      |
| **자원 및 보안 관리** | CPU, 메모리, 저장장치 등 자원의 접근 제어 및 사용자 권한과 보안을 관리함    |

## 2. 프로세스
### 1. 프로세스 제어블록
 - 프로세스 제어블록(PCB, Process Control black)은 프로세스의 정보를 담은 하나의 구조체
 - 프로세스 ID, 프로세스 상태, 프로세스 주소, 크기등의 정보를 가지고 있음.
### 2. 프로세스 구조 
| 범주                  | 설명                                            |
| ------------------- | ----------------------------------------- |
| **프로세스 상태**         | 현재 상태 (Running, Ready, Blocked 등)             |
| **프로세스 ID (PID)**   | 고유 식별자 (Process ID)                           |
| **Program Counter** | 다음에 실행할 명령어의 주소                               |
| **CPU 레지스터**        | 연산 중이던 레지스터 값들 (R1, R2, PC, SP 등), 문맥 교환 시 저장 |
| **메모리 정보**          | 코드, 데이터, 스택 영역 주소, 페이지 테이블, 세그먼트 테이블 등        |
| **파일 정보**           | 열린 파일 핸들, 파일 디스크립터 테이블 등             |
| **스케줄링 정보**         | 우선순위, 스케줄링 큐 포인터, CPU 점유 시간 등      |
| **계정 정보**           | 사용자 ID, 그룹 ID, 권한 정보 등                 |
| **입출력 상태**          | 사용 중인 I/O 장치, 대기 중인 I/O 요청 정보 등      |

### 3. 프로세스 스케줄링
| 알고리즘 이름 (한글)      | 알고리즘 이름 (영어)                        | 설명                                           |
| ----------------- | ----------------------------------- | -------------------------------------------- |
| **선입선출 스케줄링**     | **FCFS (First-Come, First-Served)** | 먼저 도착한 순서대로 CPU를 할당함. 단순하지만 대기 시간이 길어질 수 있음. |
| **최단 작업 우선 스케줄링** | **SJF (Shortest Job First)**        | 실행 시간이 가장 짧은 작업에 먼저 CPU를 할당. 평균 대기 시간이 낮음.   |
| **라운드 로빈 스케줄링**   | **RR (Round Robin)**                | 정해진 시간(Time Quantum)만큼 CPU를 순환적으로 나눠줌. 공정함.  |
| **우선순위 스케줄링**     | **Priority Scheduling**             | 우선순위가 높은 프로세스부터 CPU를 할당. 기아 현상 가능성 있음.       |


### 4. 프로세스 상태
 - 운영체제에서 **프로세스 상태(Process States)**는 프로세스가 실행되는 동안 가질 수 있는 여러 단계(상태)
 
| 상태 이름               | 설명                            |
| ------------------- | ----------------------------- |
| **New (생성)**        | 프로세스가 생성되어 아직 준비되지 않은 상태      |
| **Ready (준비)**      | CPU 할당을 기다리는 상태, 실행 대기 중      |
| **Running (실행)**    | CPU를 할당받아 현재 명령어를 실행 중인 상태    |
| **Waiting (대기)**    | 입출력 완료 등 이벤트를 기다리는 상태 (블록 상태) |
| **Terminated (종료)** | 프로세스가 실행을 마치고 종료된 상태          |
 - 흐름
 ```
 New → Ready → Running → Waiting → Ready → Running → Terminated
 ```
   - New → Ready : 프로세스 생성 후 준비 상태로 전환
   - Ready → Running : CPU 할당 받아 실행
   - Running → Waiting : I/O 등 이벤트 대기 위해 대기 상태로 전환
   - Waiting → Ready : 이벤트 완료 후 다시 실행 대기
   - Running → Terminated : 작업 완료 후 종료
 - 문맥전환은 CPU가 실행하는 프로세스를 교체하는 작업으로 교체 당하는 프로세스의 문맥은 보관하고 교체하는 프로세스의 문맥은 복원하는 과정

### 5. 대기상태 🔍
 - OS 입장에서 JVM 전체가 "대기 상태"인 경우
   - JVM은 프로세스고, 그 안에서 여러 개의 스레드가 동작하는데, JVM 내 모든 스레드가 '대기' 또는 '차단(Blocked)' 상태가 되면, OS 입장에선 JVM 프로세스 전체가 쓸 일이 없는 프로세스 = 대기 상태로 간주함.
   - 모든 스레드가 wait(), sleep(), join()으로 Waiting 상태일 때
   - 네트워크 요청 응답을 기다리며 블로킹 I/O 수행 중일 때
   - 데이터베이스 커넥션 풀을 기다리며 Thread Pool에서 idle 상태일 때
   - GC(가비지 컬렉션) 중 일시정지(Pause-the-world) 발생 시
   
 - JVM 내부에서는 대부분의 대기 상태는 BLOCKED, WAITING, TIMED_WAITING으로 분류함. 

| 상태                 | 설명                                       |
| ------------------ | ---------------------------------------- |
| **NEW**            | 아직 시작되지 않은 상태                            |
| **RUNNABLE**       | 실행 가능 (실제로 CPU 점유할 수 있는 상태)              |
| **BLOCKED**        | 모니터 락(동기화) 획득을 기다리는 중                    |
| **WAITING**        | 명시적 대기 중 (예: `join()`, `wait()`)         |
| **TIMED\_WAITING** | 시간 제한 대기 (예: `sleep()`, `wait(timeout)`) |
| **TERMINATED**     | 실행 종료                                    |

   
 
## 3. 프로세스의 메모리영역
### 1. 프로세스 메모리 영역 
```
 +----------------------------+
 | 코드 영역 (Text Segment)     |
 +----------------------------+
 | 데이터 영역 (Data Segment)   |
 | - 초기화된 데이터             |
 | - 초기화되지 않은 데이터 (BSS) |
 +-----------------------------+
 | 힙 영역 (Heap)               |
 +-----------------------------+
 | **자유 영역 (Free Area)**     |  ← 동적 할당 가능한 여유 공간 (힙과 스택 사이) 
 +-----------------------------+
 | 스택 영역 (Stack)             |
 +-----------------------------+
```
 - 코드 영역: 프로그램 명령어들이 저장되는 영역. 보통 읽기 전용.
 - 데이터 영역: 전역 변수, 정적 변수들이 저장됨. 초기화 여부에 따라 나눔.
 - 힙 영역: 런타임 중 동적 메모리 할당을 위한 영역.
 - 자유 영역: 힙과 스택 사이에 남아있는 비할당 메모리 공간.
 - 스택 영역: 함수 호출 시 생성되는 지역 변수, 매개변수, 리턴 주소 등이 저장됨.

### 2. 프로세스의 메모리 영역 구조가 같은 이유 🔍
 - 운영체제 설계의 표준화
   - 대부분 운영체제(OS)는 프로세스를 효율적으로 관리하기 위해 일관된 메모리 구조 모델 사용
   - CPU, 메모리 관리장치(MMU), 가상 메모리 시스템, 스케줄러 등 시스템 구성 요소들이
프로세스를 공통된 방식으로 다룰 수 있음.
 - 프로그램 실행 방식의 공통성
   - 프로그램 실행은 기본적으로 코드 실행 → 데이터 사용 → 동적 메모리 할당 → 함수 호출과 반환 과정을 거침
   - 이 흐름에 맞춰 메모리를 나누면 구조가 자연스럽게 코드/데이터/힙/스택 으로 나뉨

 - 가상 메모리 관리와 보호를 위한 논리적 분할
   - 각 영역별로 접근 권한(읽기, 쓰기, 실행)을 다르게 주고, 메모리 충돌이나 오염을 막기 위해 영역을 분리함
   - 이런 분리는 OS가 안정성과 보안을 유지하는 데 필수적
  - 컴파일러와 링커의 역할
    - 컴파일러는 코드, 전역 변수, 정적 변수, 초기화되지 않은 변수 등을 각각 다른 세그먼트에 배치함.