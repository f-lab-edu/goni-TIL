## 1. 데이터 지역성

### 1. 데이터 지역성(Locality of Reference)
- 프로그램이 메모리에 접근할 때, 특정 위치 근처의 데이터나 같은 데이터를 반복적으로 접근하는 경향성
- CPU는 메모리보다 속도가 훨씬 빠르기 때문에, 자주 쓰이는 데이터는 캐시에 저장해 두고, 지역성이 높을수록 캐시 적중률(Cache Hit Rate)이 높아져 전체 시스템 속도가 비약적으로 빨라짐

### 2. 시간지역성, 공간 지역성
- 시간지역성
  ```
  // 시간 지역성
  int x = arr[0];
  for (int i = 0; i < 1000; i++) {
  sum += x;       // 같은 값 x를 계속 사용
  }
   ```
  - 최근에 접근한 데이터는 가까운 미래에 다시 접근할 가능성이 큼
  - 반복문 안에서 같은 변수 계속 접근할 가능성이 높다.

   

- 공간지역성
  ```
  // 공간 지역성
  for (int i = 0; i < N; i++) {
      sum += arr[i];  // arr[i]는 메모리에 연속 배치
  }
  ```
    - 현재 접근 중인 주소 근처의 데이터도 곧 접근할 가능성이 큼
    - 배열 순차 탐색, 구조체 필드 연속 접근

## 2. 캐시
### 1. 캐시 위치
- 캐시 구조

| 캐시 레벨     | 위치                  | 크기                 | 속도                 | 용도 및 특징                                 |
| --------- | ------------------- | ------------------ | ------------------ | --------------------------------------- |
| **L1 캐시** | CPU 코어 내부 (가장 가까움)  | 아주 작음 (수십 KB)      | 가장 빠름 (\~수 ns)     | 명령어와 데이터용으로 분리되어 있음 (L1i, L1d), 코어별 독립적 |
| **L2 캐시** | CPU 코어 내부 (L1 다음)   | 작음 (수백 KB \~ 몇 MB) | L1보다 느림 (수십 ns)    | 코어별 전용 캐시, L1 미스 시 참조                   |
| **L3 캐시** | CPU 칩 내부, 여러 코어가 공유 | 큼 (수 MB \~ 수십 MB)  | L2보다 느림 (100ns 이상) | 여러 코어가 공유, 코어 간 데이터 일관성 유지 지원           |

- 모양
```
   +----------------------------+      +----------------------------+
  |        CPU Core 1           |      |        CPU Core 2           |
  |  +--------+   +--------+    |      |  +--------+   +--------+    |
  |  |  L1 I  |   |  L1 D  |    |      |  |  L1 I  |   |  L1 D  |    |
  |  +--------+   +--------+    |      |  +--------+   +--------+    |
  |        |           |        |      |        |           |         |
  |        +----+------+        |      |        +----+------+         |
  |             |               |      |             |               |
  |           +-------+         |      |           +-------+         |
  |           |  L2   |         |      |           |  L2   |         |
  |           +-------+         |      |           +-------+         |
  +----------------------------+      +----------------------------+
                |                              |
                +-------------+----------------+
                              |
                     +------------------+
                     |       L3 Cache   |  ← 코어 1, 2가 공유하는 L3 캐시
                     +------------------+
                              |
                              |
                        +---------+
                        |   RAM   |  ← 메인 메모리 (느림)
                        +---------+
```


- 캐시 위치
```
+--------------------+      +--------------------+
|    CPU (Processor) | <--> |       Cache        | <--> RAM (Main Memory)
+--------------------+      +--------------------+
                                  ▲
                                  |
                           캐시 블록들 (Cache Blocks)
```
※ 캐시에 필요한 데이터가 많이 캐싱 될수록 CPU는 상대적으로 느린 RAM 접근을 덜 하게 됨

### 2. 캐시 적중률 / 미스 🔍
| 구분               | 설명                            |
| ---------------- | ---------------------------- |
| **캐시 적중 (Hit)**  | CPU가 필요한 데이터를 **캐시에서 바로 찾은 경우** → 빠르게 처리됨                    |
| **캐시 미스 (Miss)** | CPU가 필요한 데이터를 **캐시에 못 찾고 RAM 등에서 다시 불러와야 하는 경우** → 느림, 비용 발생 |

## 3. 캐시 적중률 높이는 소스 🔍
1. 배열은 순차적으로 접근하기 (Spatial Locality 활용)
 ```
 // 배열은 메모리에 연속적으로 저장되므로, 순서대로 접근하면 같은 캐시 라인 안에서 데이터를 읽을 수 있음
 for (int i = 0; i < arr.length; i++) {
     sum += arr[i];
 }
 ```
2. 객체 구조 대신 기본형 배열 사용 (배열은 연속 메모리)
 ```
int[] x = new int[1000];
  Integer[] y = new Integer[1000];

  // Integer[]는 내부적으로 각각의 Integer 객체가 힙의 다른 위치에 저장되므로 캐시 미스가 더 많이 발생함.
 ```

3. 클래스 설계에서 필드 접근 최소화 (Temporal Locality 활용)
 ```
 class User {
    String name;
    int age;
    int id;
 }

 // 캐시 친화적
 // 한 객체의 여러 필드를 연달아 접근하면 같은 캐시 라인 안에 존재할 확률이 높음.
 for (User u : users) {
     totalAge += u.age;
     totalId += u.id;z
 } 

 // 비효율적 (필드 접근 분산)
 for (User u : users) {
     if (someCondition) println(u.name);
 }

 ```
4. 데이터를 가볍고 밀집되게 만들기 (Data Locality Up)
 ```
 // 구조를 나누기보단, 필요한 데이터만 가지는 구조로 설계
// 클래스 내부의 불필요한 필드를 줄이고, 핫 데이터만 밀도 있게 유지하면 캐시 효율이 높아짐.
 class LightUser {
     int id;
    int age;  // 필요한 최소 필드만 유지
 }
 ```

5. LinkedList보다 ArrayList를 우선 사용
 ```
 List<Integer> list = new ArrayList<>(); // 캐시 적중률 높음
 List<Integer> list = new LinkedList<>(); // 노드는 메모리 분산됨
 // ArrayList는 연속된 메모리 공간을 사용하지만,
 // LinkedList는 각 노드가 흩어진 위치에 저장되어 캐시 미스 유발 가능성이 큼.
 ```